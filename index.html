<!DOCTYPE html>
<html>
  <head>
    <title>Hashed Wiki</title>
    <style>
      :root {
        --pad: 1em;
        color-scheme: light dark
      }

      * { box-sizing: border-box }

      html, body, main {
        width: 100%;
        height: 100%;
        margin: 0
      }

      body {
        overflow: hidden
      }

      main {
        display: flex;
        height: 100%
      }

      textarea {
        width: 50%;
        height: 100%;
        margin: 0;
        padding: var(--pad);
        font-family: monospace;
        white-space: pre-wrap;
        outline: none;
        border: none;
        resize: none
      }

      iframe {
        width: 50%;
        height: 100%;
        border: none
      }
    </style>
  </head>
  <body>
    <main>
      <textarea spellcheck="false"></textarea>
      <iframe></iframe>
    </main>
    <script>
      class Editor {
        constructor() {
          this.dbName = 'uris'
          this.storeName = 'uri'
          this.db = null
          this.saveTimeout = null
          this.editor = document.querySelector('textarea')
          this.preview = document.querySelector('iframe')
          this.hooks = {
            beforeSave: [],
            afterSave: [],
            beforeLoad: [],
            afterLoad: []
          }

          this.init()
        }

        async init() {
          await this.initDB()
          this.bindEvents()
          
          if (!location.hash) {
            location.hash = 'home'
          } else {
            await this.loadContent()
          }
          
          this.editor.focus()
        }

        initDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1)
            request.onupgradeneeded = (event) => {
              this.db = event.target.result
              this.db.createObjectStore(this.storeName, { keyPath: 'key' })
            }
            request.onsuccess = (event) => {
              this.db = event.target.result
              resolve()
            }
            request.onerror = (event) => {
              console.error('Database error:', event.target.errorCode)
              reject(event.target.errorCode)
            }
          })
        }

        bindEvents() {
          this.editor.addEventListener('input', () => {
            clearTimeout(this.saveTimeout)
            this.saveTimeout = setTimeout(() => this.saveContent(), 1000)
            this.updatePreview()
          })

          window.addEventListener('hashchange', () => this.loadContent())
        }

        updatePreview() {
          const doc = this.preview.contentDocument
          doc.open()
          doc.write(this.editor.value)
          doc.close()
          this.executeScripts(doc)
        }

        executeScripts(doc) {
          const scripts = doc.getElementsByTagName('script')
          Array.from(scripts).forEach(oldScript => {
            const newScript = doc.createElement('script')
            Array.from(oldScript.attributes).forEach(attr => {
              newScript.setAttribute(attr.name, attr.value)
            })
            newScript.textContent = oldScript.textContent
            oldScript.parentNode.replaceChild(newScript, oldScript)
          })
        }

        getDefaultContent() {
          return `Welcome to your Universal Interface

This is a URL-based universal interface, where everything after the #hash in the URL points to a unique page.

Usage:
- Use #home to access the main page
- Use #reset to clear all data
- Use #source to view source code
- Use any other #hash to create/edit new pages`
        }

        async loadContent() {
          const hash = location.hash.slice(1) || 'home'
          
          for (const hook of this.hooks.beforeLoad) {
            await hook(hash)
          }

          if (hash === 'reset') {
            await this.resetDB()
            location.hash = 'home'
            return
          }

          if (hash === 'source') {
            const response = await fetch(location.pathname)
            const sourceCode = await response.text()
            this.editor.value = sourceCode
            this.updatePreview()
            return
          }

          const transaction = this.db.transaction([this.storeName], 'readonly')
          const store = transaction.objectStore(this.storeName)
          const request = store.get(hash)

          request.onsuccess = async (event) => {
            const result = event.target.result
            
            if (!result && hash === 'home') {
              this.editor.value = this.getDefaultContent()
              await this.saveContent()
            } else {
              this.editor.value = result ? result.value : ''
            }
            
            this.updatePreview()
            
            for (const hook of this.hooks.afterLoad) {
              await hook(hash)
            }
          }
        }

        async saveContent() {
          const hash = location.hash.slice(1) || 'home'
          if (['source', 'reset'].includes(hash)) return

          for (const hook of this.hooks.beforeSave) {
            await hook(hash, this.editor.value)
          }

          const transaction = this.db.transaction([this.storeName], 'readwrite')
          const store = transaction.objectStore(this.storeName)
          await store.put({
            key: hash,
            value: this.editor.value
          })

          for (const hook of this.hooks.afterSave) {
            await hook(hash, this.editor.value)
          }
        }

        async resetDB() {
          const confirmReset = confirm(
            'Are you sure you want to reset all data? This action cannot be undone.'
          )
          if (!confirmReset) {
            location.hash = 'home'
            return
          }

          return new Promise((resolve) => {
            this.db.close()
            const req = indexedDB.deleteDatabase(this.dbName)
            req.onsuccess = () => {
              this.initDB().then(resolve)
            }
          })
        }
      }

      new Editor
    </script>
  </body>
</html>
