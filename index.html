<!DOCTYPE html>
<html>
  <head>
    <title>Universal Editor</title>
    <style>
      :root {
        --pad: 1em;
        color-scheme: light dark;
        --bg: #ffffff;
        --fg: #000000;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #1a1a1a;
          --fg: #ffffff;
        }
      }

      * {
        box-sizing: border-box;
      }

      html,
      body,
      main {
        width: 100%;
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--fg);
      }

      main {
        padding: var(--pad);
        overflow: auto;
        outline: none;
        font-family: system-ui, -apple-system, sans-serif;
        line-height: 1.5;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <main contenteditable></main>
    <script>
      class Editor {
        constructor() {
          this.dbName = "uris";
          this.storeName = "uri";
          this.db = null;
          this.saveTimeout = null;
          this.$ = document.querySelector("main");
          this.$.innerHTML = this.$.textContent;

          this.init();
          this.bindEvents();
        }

        async init() {
          await this.initDB();
          if (!location.hash) {
            location.hash = "home";
          }
          this.loadContent();
        }

        initDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);

            request.onupgradeneeded = (event) => {
              this.db = event.target.result;
              this.db.createObjectStore(this.storeName, { keyPath: "key" });
            };

            request.onsuccess = (event) => {
              this.db = event.target.result;
              resolve();
            };

            request.onerror = (event) => {
              console.error("Database error:", event.target.errorCode);
              reject(event.target.errorCode);
            };
          });
        }

        bindEvents() {
          this.$.addEventListener("input", () => {
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => this.saveContent(), 1000);
          });

          window.addEventListener("hashchange", () => this.loadContent());
        }

        executeScripts(element) {
          const scripts = element.querySelectorAll("script");
          scripts.forEach((oldScript) => {
            const newScript = document.createElement("script");
            Array.from(oldScript.attributes).forEach((attr) => {
              newScript.setAttribute(attr.name, attr.value);
            });
            newScript.textContent = oldScript.textContent;
            oldScript.parentNode.replaceChild(newScript, oldScript);
          });
        }

        async loadReadme() {
          try {
            // Try to fetch README.md from the same directory
            const response = await fetch("README.md");
            if (!response.ok) throw new Error("README not found");
            return await response.text();
          } catch (error) {
            // Fallback content if fetch fails
            return `<h1>Welcome to your Universal Interface</h1>
	
This is a URL-based universal interface, where everything after the #hash in the URL points to a unique in-memory HTML page, stored in the <code>page</code> table of the <code>pages</code> IndexedDB database in your browser. This data is cleared automatically if you are in your browser's Private/Incognito Mode or whenever you manually clear your browser's cache

<h2>Usage</h2>
- Use <a href="#home">#home</a> to access the main page
- Use <a href="#reset">#reset</a> to clear all data
- Use <a href="#source">#source</a> to view source code
- Use any other #hash to create/edit new pages`;
          }
        }

        async loadContent() {
          const hash = location.hash.slice(1) || "home";

          // Handle #reset
          if (hash === "reset") {
            await this.resetDB();
            location.hash = "home";
            return;
          }

          // Handle #source
          if (hash === "source") {
            const response = await fetch(location.pathname);
            const sourceCode = await response.text();
            this.$.textContent = sourceCode;
            return;
          }

          // Handle #home when empty
          if (hash === "home") {
            const transaction = this.db.transaction(
              [this.storeName],
              "readonly"
            );
            const store = transaction.objectStore(this.storeName);
            const request = store.get(hash);

            request.onsuccess = async (event) => {
              if (!event.target.result) {
                try {
                  const readme = await this.loadReadme();
                  this.$.innerHTML = readme;
                  this.saveContent();
                } catch (e) {
                  console.log("No README loaded");
                  this.$.innerHTML = "";
                }
                return;
              }
              this.$.innerHTML = event.target.result.value;
              this.executeScripts(this.$);
            };
            return;
          }

          // Handle regular pages
          const transaction = this.db.transaction([this.storeName], "readonly");
          const store = transaction.objectStore(this.storeName);
          const request = store.get(hash);

          request.onsuccess = (event) => {
            const result = event.target.result;
            this.$.innerHTML = result ? result.value : "";
            if (result) {
              this.executeScripts(this.$);
            }
          };
        }

        saveContent() {
          const hash = location.hash.slice(1) || "home";

          if (["source", "reset"].includes(hash)) return;

          const transaction = this.db.transaction(
            [this.storeName],
            "readwrite"
          );
          const store = transaction.objectStore(this.storeName);
          store.put({
            key: hash,
            value: this.$.innerHTML,
          });
        }

        async resetDB() {
          const confirmReset = confirm(
            "Are you sure you want to reset all data? This action cannot be undone."
          );
          if (!confirmReset) {
            location.hash = "home";
            return;
          }

          return new Promise((resolve) => {
            this.db.close();
            const req = indexedDB.deleteDatabase(this.dbName);
            req.onsuccess = () => {
              this.initDB().then(resolve);
            };
          });
        }
      }

      // Initialize the editor
      const editor = new Editor();
    </script>
  </body>
</html>
